In this script we demonstrate how a high-level application can command the ROS navigation stack programmatically. After initializing a ROS node we create a SimpleActionClient that connects to the move_base action server, which is the central interface tying together global planning, local obstacle avoidance, and low-level velocity control. The helper function build_goal() converts an (x, y, yaw) target expressed in the map frame into a MoveBaseGoal, packaging the position and orientation as a quaternion—the format required by move_base. When the script runs we wait for the server to be ready, send the goal, and then block for up to 120 seconds while the planners generate a path and execute it. If the robot reaches the destination the action server returns SUCCEEDED; otherwise the script cancels the request, demonstrating a simple recovery pattern.

By interacting only with the action API we keep the node agnostic to the underlying robot or planners: as long as mapping, AMCL localization, and the global/local planners are active, the same code works on a TurtleBot in simulation or a physical warehouse robot. This compact example therefore encapsulates the entire navigation pipeline covered in the project—from global map reasoning down to real-time motor commands—while giving us a clean entry point to extend behavior with loops of waypoints, dynamic goal generation, or higher-level task logic.